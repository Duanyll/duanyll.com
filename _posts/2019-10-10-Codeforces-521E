---
title: CF521E Cycling City
tags: [OI, 题解, 图论]
author: duanyll
source: http://codeforces.com/problemset/problem/521/E
---

## 题意

照搬洛谷翻译。

>  给定一张$n$个点$m$条边的无向图，求图中是否存在两个点，满足该两点间有至少三条不共点（不包括起点和终点）的简单路。若不存在，则输出`"NO"`；若存在，则输出`"YES"`，并在其下三行分别输出三条路径所经过的点的编号（以空格分隔）。
> $n,m\in[1,2\times10^5]$，点的编号从$1$开始。
> 注意：图有可能不连通。

## 分析

有一个叫做仙人掌图的东西,  它的定义是这样的: 

> 任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。

![graph.png](https://i.loli.net/2019/10/10/LmfUChcTxPj4rZE.png)

上图就是一个仙人掌图, 不难发现, 仙人掌图缩环后就是一棵树, 而因为仙人掌图上只有简单环, 就是说只能找到两条不共点的路径, 对这道题他是一定无解的.

那么如果一个图不是仙人掌图, 他就一定至少存在一个这种东西:

![graph _1_.png](https://i.loli.net/2019/10/10/kYsU6MuPtirJ18x.png)

对于上图的情况, 显然有解.

我们如何判断这样的结构呢? 可以用 Tarjan 的思想进行 DFS. 我们考虑 DFS 树上的非树边: 

![dfstree.png](https://i.loli.net/2019/10/10/QzMsgAiLtl1wFGe.png)

对于左边的仙人掌图的情况, 非树边不会互相覆盖或相交; 所以如果非树边相交或覆盖了, 就存在一种解. 因此我们对于非树边差分打个标记就可以判断.

**但这道题恶心就在要输出方案.** 当我们找到了如下图的两条非树边后, 答案的起点和终点就位于这两条边下面端点的 LCA 和上面端点深度较深的一个.

![dfstree.png](https://i.loli.net/2019/10/10/WkK7pf3zdrxbET4.png)

## 代码

今天CF炸了, 下面的代码还没测过. 

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;

typedef long long int64;

const int MAXN = 200010;
const int INF = 0x3f3f3f3f;

class lfs {
   public:
    lfs(int N) {
        memset(head, -1, sizeof head);
        ecnt = 0;
        n = N;
    }
    void adde(int from, int to, int w) {
        e[ecnt].to = to;
        e[ecnt].w = w;
        e[ecnt].next = head[from];
        head[from] = ecnt++;
    }
    void addde(int a, int b, int w) {
        adde(a, b, w);
        adde(b, a, w);
    }
    
    void solve() {
    	memset(dep, -1, sizeof dep);
    	memset(d, 0, sizeof d);
    	memset(f, 0, sizeof f);
    	dfs1(1, 0);
    	last_edge = -1;
    	ans_found = false;
    	dfs2(1, 0);
    	if (!ans_found) cout << "NO" << endl;
	}

   protected:
    struct Edge {
        int to, next, w;
    } e[MAXN * 2];
    int head[MAXN];
    int ecnt;
    int n;
    
    int dep[MAXN];
    int d[MAXN];
    int f[MAXN];
    
    void dfs1(int u, int fa) {
    	f[u] = fa;
    	dep[u] = dep[fa] + 1;
    	for (int i = head[u]; i != -1; i = e[i].next) {
    		int v = e[i].to;
    		if (v != fa) {
    		    if (dep[v] != -1 && dep[v] < dep[u]) {
    		   	  	d[v]++;
    				d[u]--;
				} else if (dep[v] == -1) {
				    dfs1(v, u);
				}
			}
		}
	}
	
	int last_edge;
	void dfs2(int u, int fa) {
		d[u] += d[fa];
		if (d[u] >= 2) {
			for (int i = head[u]; i != -1; i = e[i].next) {
				int v = e[i].to;
				if (dep[v] > dep[u] + 1) {
					if (last_edge == -1) 
					    last_edge = i;
		 		    else {
		 		    	output(last_edge, i);
		 		    	return;
				    }
				}
			}
		}
		for (int i = head[u]; i != -1; i = e[i].next) {
			int v = e[i].to;
			if (dep[v] > dep[u] + 1) {
			    last_edge = i;
			} else if (dep[v] == dep[u] + 1) {
				dfs2(v, u);
	   			if (ans_found) return;
			}
		}
	}
	
	void reverse(vector<int>& vec) {
		for (int i = 0; i < vec.size() - i - 1; i++) {
			swap(vec[i], vec[vec.size() - i - 1]);
		}
	}
	
	bool ans_found;
	void output(int e1, int e2) {
		ans_found = true;
		if (dep[e[e1].to] > dep[e[e2].to]) swap(e1, e2);
		int v1 = e[e1].to, v2 = e[e2].to;
		vector<int> ans1, ans2, ans3;
		ans1.push_back(v1);
		ans2.push_back(v2);
		while (dep[v1] < dep[v2]) {
			v1 = f[v1];
			ans1.push_back(v1);
		}
		while (v1 != v2) {
			v1 = f[v1];
			ans1.push_back(v1);
			v2 = f[v2];
			ans2.push_back(v2);
		}
		reverse(ans1);
		reverse(ans2);
		int u1 = e[e1 ^ 1].to, u2 = e[e2 ^ 1].to;
		ans1.push_back(u1);
		ans2.push_back(u2);
		int u = v1;
		ans3.push_back(u);
		while (u != u1 && u != u2) {
			u = f[u];
			ans3.push_back(u);
		}
		vector<int> tmp;
		if (u == u1) {
			while (u != u2) {
				tmp.push_back(u);
				u = f[u];
			}
			for (int i = tmp.size() - 1; i >= 0; i--) {
				ans2.push_back(tmp[i]);
			}
		} else {
			while (u != u1) {
				tmp.push_back(u);
				u = f[u];
			}
			for (int i = tmp.size() - 1; i >= 0; i--) {
				ans1.push_back(tmp[i]);
			}
		}
		
		cout << "YES" << endl;
		for (int i = 0; i < ans1.size(); i++) {
			cout << ans1[i] << ' ';
		}
		cout << endl;
		for (int i = 0; i < ans2.size(); i++) {
			cout << ans2[i] << ' ';
		}
		cout << endl;
		for (int i = 0; i < ans3.size(); i++) {
			cout << ans3[i] << ' ';
		}
		cout << endl;
	}
};

#include <cctype>
#include <cstdio>

template <typename T = int>
inline T read() {
    T X = 0, w = 0;
    char ch = 0;
    while (!isdigit(ch)) {
        w |= ch == '-';
        ch = getchar();
    }
    while (isdigit(ch)) {
        X = (X << 3) + (X << 1) + (ch ^ 48);
        ch = getchar();
    }
    return w ? -X : X;
}

int main() {
	int n = read();
	int m = read();
	lfs* tree = new lfs(n);
	for (int i = 1; i <= m; i++) {
		tree->addde(read(), read(), 1);
	}
	tree->solve();
}
```
